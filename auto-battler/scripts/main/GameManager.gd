class_name GameManagerRoot
extends Node

## Manages global game state, persistent data, and scene/phase transitions for the auto-battler.
## Connects signals from various specialized managers to orchestrate the game flow.

# Signal for UI or other systems to react to game phase changes.
signal game_phase_changed(new_phase_name: String)

# --- Persistent Data Variables ---
# Holds CharacterData objects/dictionaries for the current party.
var current_party_members: Array = []
# Player's inventory: cards, gear, consumables, currency.
var player_inventory: Dictionary = {
    "cards": [],
    "gear": [],
    "consumables": [],
    "currency": 0
}
# State of the current dungeon run.
var current_dungeon_state: Dictionary = {
    "depth": 0,             # Current depth or level in the dungeon
    "map_data": null,       # Procedurally generated map for the current level
    "current_node_id": null # Player's current position on the map
}
# Current high-level game phase. String for flexibility.
var current_game_phase: String = "main_menu"

# --- Manager Node Paths (adjust if using unique names or different scene structure) ---
# These are placeholders. Actual node access might need to be /root/SceneName/ManagerName
const PREPARATION_MANAGER_PATH := "PreparationManager" # Placeholder path
const DUNGEON_MAP_MANAGER_PATH := "DungeonMapManager"   # Placeholder path
const COMBAT_MANAGER_PATH := "CombatManager"           # Placeholder path
const POST_BATTLE_MANAGER_PATH := "PostBattleManager" # Placeholder path
const REST_MANAGER_PATH := "RestManager"               # Placeholder path

# --- Core Game State Functions ---
func _ready() -> void:
    print("GameManager: Initializing...")

    # Defer manager lookups until their scenes are loaded to avoid missing nodes
    # during engine startup.

    # Initialize game, potentially load initial data or set up for main menu.
    # For a new game, this might mean transitioning to a main menu scene.
    if get_tree().current_scene == null && !Engine.is_editor_hint():
        _change_game_phase_and_scene("main_menu", "res://auto-battler/scenes/MainMenu.tscn")

    print("GameManager: Initialization complete. Current phase: %s" % current_game_phase)


## Starts a new dungeon run with selected party and gear.
func start_new_run(selected_party_composition: Array, initial_gear: Array = []) -> void:
    print("GameManager: Starting new run.")
    reset_game_state() # Clear any previous run data
    # Initialize current_party_members based on selected_party_composition.
    # This involves creating CharacterData instances/dictionaries with base stats, cards, gear.
    # Placeholder: Assume selected_party_composition contains pre-defined CharacterData objects/dictionaries.
    current_party_members = selected_party_composition.duplicate(true)
    for member_data in current_party_members:
        if not member_data.has("hp"): member_data["hp"] = member_data.get("base_hp", 100) # Ensure HP is set
        if not member_data.has("statuses"): member_data["statuses"] = {}
        if not member_data.has("fatigue"): member_data["fatigue"] = 0
        if not member_data.has("hunger"): member_data["hunger"] = 0
        if not member_data.has("thirst"): member_data["thirst"] = 0
        # Assign initial_gear if applicable (more complex logic might be needed for specific assignment)

    # Initialize player_inventory (e.g., with starting consumables).
    player_inventory = {
        "cards": [], # Initial cards might come from party members' default decks
        "gear": initial_gear,
        "consumables": [], # Example: [load("res://resources/consumables/healing_potion.tres")]
        "currency": 100
    }

    # Initialize current_dungeon_state.
    current_dungeon_state = {
        "depth": 1,
        "map_data": null, # To be generated by DungeonMapManager
        "current_node_id": null # Starting node
    }

    _change_game_phase_and_scene("preparation", "res://auto-battler/scenes/PreparationScene.tscn") # Example path

    # Inform PreparationManager to load data.
    # Ensure PreparationManager is ready in the new scene before calling its methods.
    # Using call_deferred to wait for the scene to fully load.
    call_deferred("_notify_preparation_manager_to_load_data")

## Resets all persistent data back to defaults for a brand new run.
func reset_game_state() -> void:
    current_party_members = []
    player_inventory = {
        "cards": [],
        "gear": [],
        "consumables": [],
        "currency": 0
    }
    current_dungeon_state = {
        "depth": 0,
        "map_data": null,
        "current_node_id": null
    }
    current_game_phase = "main_menu"

func _notify_preparation_manager_to_load_data():
    var prep_manager = get_node_or_null(PREPARATION_MANAGER_PATH) # Adjust path if it's inside PrepScene
    if prep_manager and prep_manager.has_method("load_party_data"):
        # PreparationManager's load_party_data might need specific parts of inventory or party data.
        # For now, pass the main structures. It should know what to pick.
        prep_manager.load_party_data() # It should use GameManager's getters
    else:
        printerr("GameManager: Failed to notify PreparationManager or method not found.")


## Starts the dungeon map using the prepared party data.
func start_dungeon_run(party_data: Array) -> void:
    current_party_members = party_data.duplicate(true)
    _change_game_phase_and_scene("dungeon_map", "res://auto-battler/scenes/DungeonMap.tscn")
    call_deferred("_notify_dungeon_map_manager_to_initialize")


## Saves the current game state to a specified slot.
func save_game_state(slot_name: String) -> void:
    var save_path := "user://%s.save" % slot_name
    var file := FileAccess.open(save_path, FileAccess.WRITE)
    if file:
        var data = {
            "party": current_party_members,
            "inventory": player_inventory,
            "dungeon": current_dungeon_state,
            "phase": current_game_phase
        }
        file.store_var(data)
        file.close()
        print("GameManager: Saved game state to %s" % save_path)
    else:
        printerr("GameManager: Failed to open %s for saving" % save_path)


## Loads game state from a specified slot.
func load_game_state(slot_name: String) -> void:
    var save_path := "user://%s.save" % slot_name
    var file := FileAccess.open(save_path, FileAccess.READ)
    if file:
        var data = file.get_var()
        file.close()
        if typeof(data) == TYPE_DICTIONARY:
            current_party_members = data.get("party", [])
            player_inventory = data.get("inventory", {})
            current_dungeon_state = data.get("dungeon", {})
            var phase = data.get("phase", "main_menu")
            var scene_map = {
                "main_menu": "res://auto-battler/scenes/MainMenu.tscn",
                "preparation": "res://auto-battler/scenes/PreparationScene.tscn",
                "dungeon_map": "res://auto-battler/scenes/DungeonMap.tscn",
                "combat": "res://auto-battler/scenes/CombatScene.tscn",
                "rest": "res://auto-battler/scenes/RestScene.tscn",
                "game_over": "res://auto-battler/scenes/GameOverScreen.tscn"
            }
            var scene = scene_map.get(phase, "res://auto-battler/scenes/MainMenu.tscn")
            _change_game_phase_and_scene(phase, scene)
            print("GameManager: Loaded game state from %s" % save_path)
        else:
            printerr("GameManager: Invalid data in %s" % save_path)
    else:
        printerr("GameManager: Failed to open %s for loading" % save_path)


# --- Getter Functions for other managers to access game state ---
func get_current_party_data() -> Array:
    return current_party_members

func get_player_inventory() -> Dictionary:
    return player_inventory

func get_current_dungeon_state() -> Dictionary:
    return current_dungeon_state

func get_current_game_phase() -> String:
    return current_game_phase

## Helper to check if at least one party member is alive
func _party_is_alive() -> bool:
    for member in current_party_members:
        if member.get("hp", 0) > 0:
            return true
    return false

## Ends the current run and optionally starts another
##  save_slot: if provided, game state will be saved to this slot
##  show_results: display a summary/run results scene before returning to menu
##  repeat: immediately start a new run with surviving party members
func end_current_run(save_slot: String = "", show_results: bool = false, repeat: bool = false, results_scene: String = "res://auto-battler/scenes/MainMenu.tscn") -> void:
    print("GameManager: Ending current run.")
    if save_slot != "":
        save_game_state(save_slot)

    var survivors := current_party_members.duplicate(true)

    if repeat and _party_is_alive():
        print("GameManager: Restarting run with surviving party.")
        start_new_run(survivors)
        return

    reset_game_state()

    if show_results:
        # A dedicated summary scene could be shown here. Use the provided scene path or main menu as placeholder.
        _change_game_phase_and_scene("run_summary", results_scene)
    else:
        _change_game_phase_and_scene("main_menu", "res://auto-battler/scenes/MainMenu.tscn")


# --- Scene/Phase Transition Logic ---
## Helper function to change game phase and current scene.
func _change_game_phase_and_scene(new_phase: String, scene_path: String) -> void:
    print("GameManager: Changing phase to '%s', scene to '%s'." % [new_phase, scene_path])
    current_game_phase = new_phase

    # Scene changing logic
    var result = get_tree().change_scene_to_file(scene_path)
    if result != OK:
        printerr("GameManager: Error changing scene to %s. Result code: %s" % [scene_path, result])
        # Potentially handle error, e.g., by trying to go to a fallback scene or main menu.
        return

    emit_signal("game_phase_changed", new_phase) # For UI or other global listeners

func change_to_preparation() -> void:
    current_game_phase = "preparation"
    get_tree().change_scene_to_file("res://scenes/PreparationScene.tscn")
    yield(get_tree(), "idle_frame")
    var prep_mgr = get_tree().current_scene.get_node("PreparationManager")
    if not prep_mgr.party_ready_for_dungeon.is_connected(on_party_ready_for_dungeon):
        prep_mgr.party_ready_for_dungeon.connect(on_party_ready_for_dungeon)

func change_to_dungeon_map() -> void:
    current_game_phase = "dungeon_map"
    get_tree().change_scene_to_file("res://scenes/DungeonMap.tscn")
    yield(get_tree(), "idle_frame")
    var map_mgr = get_tree().current_scene.get_node("DungeonMapManager")
    if not map_mgr.transition_to_combat.is_connected(on_transition_to_combat_requested):
        map_mgr.transition_to_combat.connect(on_transition_to_combat_requested)
    if not map_mgr.transition_to_loot_event.is_connected(on_transition_to_loot_event_requested):
        map_mgr.transition_to_loot_event.connect(on_transition_to_loot_event_requested)
    if not map_mgr.transition_to_rest.is_connected(on_transition_to_rest_requested):
        map_mgr.transition_to_rest.connect(on_transition_to_rest_requested)
    if not map_mgr.node_selected.is_connected(on_map_node_selected):
        map_mgr.node_selected.connect(on_map_node_selected)

func change_to_combat() -> void:
    current_game_phase = "combat"
    get_tree().change_scene_to_file("res://scenes/CombatScene.tscn")
    yield(get_tree(), "idle_frame")
    var combat_mgr = get_tree().current_scene.get_node("CombatManager")
    if not combat_mgr.combat_victory.is_connected(on_combat_victory):
        combat_mgr.combat_victory.connect(on_combat_victory)
    if not combat_mgr.combat_defeat.is_connected(on_combat_defeat):
        combat_mgr.combat_defeat.connect(on_combat_defeat)

func change_to_post_battle() -> void:
    current_game_phase = "post_battle"
    get_tree().change_scene_to_file("res://scenes/PostBattleSummary.tscn")
    yield(get_tree(), "idle_frame")
    var pb_mgr = get_tree().current_scene.get_node("PostBattleManager")
    if not pb_mgr.post_battle_processing_complete.is_connected(on_post_battle_processing_complete):
        pb_mgr.post_battle_processing_complete.connect(on_post_battle_processing_complete)
    if not pb_mgr.transition_to_map_requested.is_connected(on_transition_to_map_requested):
        pb_mgr.transition_to_map_requested.connect(on_transition_to_map_requested)
    if not pb_mgr.transition_to_rest_requested.is_connected(on_transition_to_rest_requested_from_post_battle):
        pb_mgr.transition_to_rest_requested.connect(on_transition_to_rest_requested_from_post_battle)
    if not pb_mgr.transition_to_game_over_requested.is_connected(on_game_over_requested):
        pb_mgr.transition_to_game_over_requested.connect(on_game_over_requested)

func change_to_rest() -> void:
    current_game_phase = "rest"
    get_tree().change_scene_to_file("res://scenes/RestScene.tscn")
    yield(get_tree(), "idle_frame")
    var rest_mgr = get_tree().current_scene.get_node("RestManager")
    if not rest_mgr.rest_continue_exploration.is_connected(on_rest_continue_exploration):
        rest_mgr.rest_continue_exploration.connect(on_rest_continue_exploration)
    if not rest_mgr.rest_exit_dungeon.is_connected(on_rest_exit_dungeon):
        rest_mgr.rest_exit_dungeon.connect(on_rest_exit_dungeon)


# --- Handler Functions for Signals from Other Managers ---
## Called when PreparationManager signals party is ready for the dungeon.
func on_party_ready_for_dungeon() -> void: # Removed arguments as PrepManager now uses getters
    print("GameManager: Party ready for dungeon. Transitioning to DungeonMap.")
    # current_party_members should have been updated by PreparationManager via direct setters or by saving to a shared resource.
    # For this pattern, assume PreparationManager calls getters on GameManager if it needs fresh data,
    # or GameManager fetches from PrepManager if data is modified there.
    # Simpler: Assume PrepManager has updated any necessary global state or its own state that DungeonMapManager will use.

    _change_game_phase_and_scene("dungeon_map", "res://auto-battler/scenes/DungeonMap.tscn") # Example path
    call_deferred("_notify_dungeon_map_manager_to_initialize")

func _notify_dungeon_map_manager_to_initialize():
    var map_manager = get_node_or_null(DUNGEON_MAP_MANAGER_PATH)
    if map_manager and map_manager.has_method("generate_procedural_map"): # Check for a method it should have
        # DungeonMapManager should use getters from GameManager to fetch party/dungeon state.
        map_manager.generate_procedural_map() # Or a more specific init function if needed
        map_manager.display_map()
    else:
        printerr("GameManager: Failed to notify DungeonMapManager or method not found.")

func on_map_node_selected(node_type: String) -> void:
    match node_type:
        "combat":
            _change_game_phase_and_scene("combat", "res://auto-battler/scenes/CombatScene.tscn")
        "rest":
            _change_game_phase_and_scene("rest", "res://auto-battler/scenes/RestScene.tscn")
        "loot":
            _change_game_phase_and_scene("loot", "res://auto-battler/scenes/LootPanel.tscn")
        _:
            print("GameManager: Unknown node type '%s' selected." % node_type)


## Called when DungeonMapManager requests a transition to combat.
func on_transition_to_combat_requested(combat_setup_data: Dictionary) -> void:
    # combat_setup_data should include { "enemies": [EnemyResource/Data], "environment_effects": [] (optional) }
    print("GameManager: Transition to combat requested.")
    _change_game_phase_and_scene("combat", "res://auto-battler/scenes/CombatScene.tscn") # Example path

    call_deferred("_notify_combat_manager_to_initialize", combat_setup_data)

func _notify_combat_manager_to_initialize(combat_setup_data: Dictionary):
    var combat_manager = get_node_or_null(COMBAT_MANAGER_PATH)
    if combat_manager and combat_manager.has_method("initialize_combat"):
        if not combat_manager.combat_victory.is_connected(on_combat_victory):
            combat_manager.combat_victory.connect(on_combat_victory)
        if not combat_manager.combat_defeat.is_connected(on_combat_defeat):
            combat_manager.combat_defeat.connect(on_combat_defeat)
        var enemy_data_list = combat_setup_data.get("enemies", [])
        combat_manager.initialize_combat(current_party_members, enemy_data_list)
        combat_manager.run_auto_battle_loop() # Start the battle
    else:
        printerr("GameManager: Failed to notify CombatManager or method not found.")


## Called when DungeonMapManager requests a transition to a loot or event node.
func on_transition_to_loot_event_requested(event_data: Dictionary) -> void:
    # This is a placeholder. How loot/events are handled (popups vs. scenes) affects this.
    # If they are full scenes:
    #   _change_game_phase_and_scene("event", "res://path_to_event_scene.tscn")
    #   Then, get the EventManager node and initialize it with event_data.
    # If they are popups managed within DungeonMapManager, DungeonMapManager handles it,
    # and GameManager might only need to know if game state changes significantly (e.g., item obtained).
    # For now, assume DungeonMapManager handles these as popups or internal UI changes.
    # If a scene change IS required, DungeonMapManager should emit a more specific signal
    # that GameManager is connected to, similar to on_transition_to_combat_requested.
    print("GameManager: Loot/event interaction requested (data: %s). Assuming DungeonMapManager handles UI." % str(event_data))
    # No phase/scene change here unless events are dedicated scenes.


## Called when DungeonMapManager requests a transition to a rest area.
func on_transition_to_rest_requested(rest_setup_data: Dictionary = {}) -> void: # Added default for calls from PostBattle
    print("GameManager: Transition to rest requested.")
    _change_game_phase_and_scene("rest", "res://auto-battler/scenes/RestScene.tscn") # Example path

    call_deferred("_notify_rest_manager_to_initialize")

func _notify_rest_manager_to_initialize():
    var rest_manager = get_node_or_null(REST_MANAGER_PATH)
    if rest_manager and rest_manager.has_method("initialize_rest_phase"):
        rest_manager.initialize_rest_phase(current_party_members, player_inventory.get("consumables", []))
    else:
        printerr("GameManager: Failed to notify RestManager or method not found.")


## Called when CombatManager signals victory.
func on_combat_victory(results: Dictionary) -> void:
    print("GameManager: Combat victory reported.")
    # results typically: { "loot": [], "xp_gained": 0, "final_party_state": [CombatantState] }

    # The final_party_state from combat (HP, statuses) needs to be passed to PostBattleManager.
    # PostBattleManager will then merge this with survival stats (fatigue, etc.)

    # No scene change yet, PostBattleManager handles the intermediate logic.
    current_game_phase = "post_battle_victory" # Internal sub-phase
    emit_signal("game_phase_changed", current_game_phase)

    var post_battle_manager = get_node_or_null(POST_BATTLE_MANAGER_PATH)
    if post_battle_manager and post_battle_manager.has_method("initialize_post_battle"):
        # Pass the combat results and the party state *before* post-battle effects like fatigue.
        post_battle_manager.initialize_post_battle(results, current_party_members.duplicate(true))
    else:
        printerr("GameManager: PostBattleManager not found or method missing for combat victory.")
        # Fallback if PostBattleManager is missing: try to go to map directly (simplified)
        # current_party_members = results.get("final_party_state", current_party_members) # Simplified update
        # on_transition_to_map_requested()


## Called when CombatManager signals defeat.
func on_combat_defeat(results: Dictionary) -> void:
    print("GameManager: Combat defeat reported.")
    # results typically: { "final_party_state": [CombatantState] }

    current_game_phase = "post_battle_defeat" # Internal sub-phase
    emit_signal("game_phase_changed", current_game_phase)

    var post_battle_manager = get_node_or_null(POST_BATTLE_MANAGER_PATH)
    if post_battle_manager and post_battle_manager.has_method("initialize_post_battle"):
        post_battle_manager.initialize_post_battle(results, current_party_members.duplicate(true))
    else:
        printerr("GameManager: PostBattleManager not found or method missing for combat defeat.")
        # Fallback if PostBattleManager is missing: go to game over directly
        # current_party_members = results.get("final_party_state", current_party_members)
        # on_game_over_requested()

## Wrapper called by CombatManager when combat ends.
func on_combat_end(victory: bool, results: Dictionary) -> void:
    if victory:
        on_combat_victory(results)
    else:
        on_combat_defeat(results)


## Called by PostBattleManager when all its processing is complete.
func on_post_battle_processing_complete(final_party_state_after_effects: Array, rewards_summary: Dictionary) -> void:
    print("GameManager: Post-battle processing complete.")
    current_party_members = final_party_state_after_effects.duplicate(true)

    # Update inventory with loot if PostBattleManager didn't do it directly
    var loot_received = rewards_summary.get("loot_received", [])
    if not loot_received.is_empty():
        if not player_inventory.has("items"): player_inventory["items"] = [] # Generic item category
        player_inventory.items.append_array(loot_received) # Example: add to a generic items list
        # Or more specific:
        # for item in loot_received:
        #   if item.type == "consumable": player_inventory.consumables.append(item)
        #   elif item.type == "gear": player_inventory.gear.append(item)
        print("GameManager: Updated inventory with loot: %s items." % loot_received.size())

    # XP application might have already been reflected in final_party_state_after_effects by PostBattleManager
    # or GameManager could do final application/level-up checks here.
    print("GameManager: Party state and rewards finalized.")
    # The PostBattleManager might have already emitted a specific transition request signal
    # which would be handled next if connected (e.g., on_transition_to_map_requested).
    # If no specific transition was requested by PostBattleManager, GameManager decides here.
    # For instance, if party wiped, PostBattleManager should have requested game over.
    # If victorious, it should have requested map or rest.
    # This handler is more for final data updates.

    # If PostBattleManager did NOT emit a specific transition signal that was caught,
    # we might need default logic here, but the current design is that PBM *will* emit one.
    # Example: if current_game_phase still "post_battle_victory", default to map.
    if current_game_phase == "post_battle_victory" and not get_tree().current_scene.name == "DungeonMap": # Avoid loop if already there
        # This check for current_scene.name is a bit hacky.
        # A more robust way is to check if a transition is already pending or using a state machine.
        # on_transition_to_map_requested() # Default if PBM didn't guide
        pass


## Called by PostBattleManager if it determines the next state is the map.
func on_transition_to_map_requested() -> void:
    print("GameManager: Transition to map requested by PostBattleManager.")
    # current_dungeon_state.depth += 1 # This might be handled by DungeonMapManager or here.
    _change_game_phase_and_scene("dungeon_map", "res://auto-battler/scenes/DungeonMap.tscn") # Example path
    call_deferred("_notify_dungeon_map_manager_to_initialize") # Re-initialize map for new state


## Called by PostBattleManager if it determines the next state is rest.
func on_transition_to_rest_requested_from_post_battle() -> void:
    print("GameManager: Transition to rest requested by PostBattleManager.")
    on_transition_to_rest_requested({}) # Call the main handler, pass empty dict if no specific data from PBM


## Called by PostBattleManager if it determines the game should end.
func on_game_over_requested() -> void:
    print("GameManager: Game over requested.")
    # Show game over screen, then return to menu when player acknowledges
    end_current_run("autosave", true, false, "res://auto-battler/scenes/GameOverScreen.tscn")


## Called when RestManager signals to continue exploration.
func on_rest_continue_exploration(updated_party_data: Array) -> void:
    print("GameManager: Continue exploration after rest.")
    current_party_members = updated_party_data.duplicate(true)

    # current_dungeon_state.depth += 1 # Or other logic to advance the dungeon
    _change_game_phase_and_scene("dungeon_map", "res://auto-battler/scenes/DungeonMap.tscn") # Example path
    call_deferred("_notify_dungeon_map_manager_to_initialize")


## Called when RestManager signals to exit the dungeon.
func on_rest_exit_dungeon(updated_party_data: Array) -> void:
    print("GameManager: Exiting dungeon after rest.")
    current_party_members = updated_party_data.duplicate(true)
    # Save progress and return to main menu or a summary screen
    end_current_run("autosave", true)

# Remove old scene transition logic if fully replaced.
# The old on_combat_finished, on_loot_complete, on_rest_complete are now handled by the new signal system.
