extends Node

var party_data

func start_run():
    print("GameManager.start_run()")
    change_to_preparation()

func change_to_preparation():
    print("GameManager.change_to_preparation()")
    get_tree().change_scene_to_file("res://scenes/PreparationScene.tscn")

func change_to_dungeon_map():
    print("GameManager.change_to_dungeon_map()")
    get_tree().change_scene_to_file("res://scenes/DungeonMap.tscn")

    # Attempt to connect signals. It's safer if managers are singletons or reliably present.
    # If managers are scene-specific, these connections might need to be established when scenes load.
    # For now, assuming managers can be globally accessed for signal connection.

    # Manager signal connections were removed due to undefined node path constants.

    # Initialize game, potentially load initial data or set up for main menu.
    # For a new game, this might mean transitioning to a main menu scene.
    if get_tree().current_scene == null && !Engine.is_editor_hint():
        _change_game_phase_and_scene("main_menu", "res://scenes/MainMenu.tscn") # Example path

    print("GameManager: Initialization complete. Current phase: %s" % current_game_phase)


## Starts a new dungeon run with selected party and gear.
func start_new_run(selected_party_composition: Array, initial_gear: Array = []) -> void:
    print("GameManager: Starting new run.")
    reset_game_state() # Clear any previous run data
    # Initialize current_party_members based on selected_party_composition.
    # This involves creating CharacterData instances/dictionaries with base stats, cards, gear.
    # Placeholder: Assume selected_party_composition contains pre-defined CharacterData objects/dictionaries.
    current_party_members = selected_party_composition.duplicate(true)
    for member_data in current_party_members:
        if not member_data.has("hp"): member_data["hp"] = member_data.get("base_hp", 100) # Ensure HP is set
        if not member_data.has("statuses"): member_data["statuses"] = {}
        if not member_data.has("fatigue"): member_data["fatigue"] = 0
        if not member_data.has("hunger"): member_data["hunger"] = 0
        if not member_data.has("thirst"): member_data["thirst"] = 0
        # Assign initial_gear if applicable (more complex logic might be needed for specific assignment)

    # Initialize player_inventory (e.g., with starting consumables).
    player_inventory = {
        "cards": [], # Initial cards might come from party members' default decks
        "gear": initial_gear,
        "consumables": [], # Example: [load("res://resources/consumables/healing_potion.tres")]
        "currency": 100
    }

    # Initialize current_dungeon_state.
    current_dungeon_state = {
        "depth": 1,
        "map_data": null, # To be generated by DungeonMapManager
        "current_node_id": null # Starting node
    }

    _change_game_phase_and_scene("preparation", "res://scenes/PreparationScene.tscn") # Example path

    # Inform PreparationManager to load data.
    # Ensure PreparationManager is ready in the new scene before calling its methods.
    # Using call_deferred to wait for the scene to fully load.
    call_deferred("_notify_preparation_manager_to_load_data")

## Resets all persistent data back to defaults for a brand new run.
func reset_game_state() -> void:
    current_party_members = []
    player_inventory = {
        "cards": [],
        "gear": [],
        "consumables": [],
        "currency": 0
    }
    current_dungeon_state = {
        "depth": 0,
        "map_data": null,
        "current_node_id": null
    }
    current_game_phase = "main_menu"

func _notify_preparation_manager_to_load_data():
    # Node path constants for managers were removed; this function remains as a placeholder
    # in case direct communication with PreparationManager is reintroduced.
    pass


## Starts the dungeon map using the prepared party data.
func start_dungeon_run(party_data: Array) -> void:
    current_party_members = party_data.duplicate(true)
    _change_game_phase_and_scene("dungeon_map", "res://scenes/DungeonMap.tscn")
    call_deferred("_notify_dungeon_map_manager_to_initialize")

## Called by PreparationScene when the player is ready.
func on_preparation_done(party_data: Array) -> void:
    start_dungeon_run(party_data)


## Saves the current game state to a specified slot.
func save_game_state(slot_name: String) -> void:
    var save_path := "user://%s.save" % slot_name
    var file := FileAccess.open(save_path, FileAccess.WRITE)
    if file:
        var data = {
            "party": current_party_members,
            "inventory": player_inventory,
            "dungeon": current_dungeon_state,
            "phase": current_game_phase
        }
        file.store_var(data)
        file.close()
        print("GameManager: Saved game state to %s" % save_path)
    else:
        printerr("GameManager: Failed to open %s for saving" % save_path)


## Loads game state from a specified slot.
func load_game_state(slot_name: String) -> void:
    var save_path := "user://%s.save" % slot_name
    var file := FileAccess.open(save_path, FileAccess.READ)
    if file:
        var data = file.get_var()
        file.close()
        if typeof(data) == TYPE_DICTIONARY:
            current_party_members = data.get("party", [])
            player_inventory = data.get("inventory", {})
            current_dungeon_state = data.get("dungeon", {})
            var phase = data.get("phase", "main_menu")
            var scene_map = {
                "main_menu": "res://scenes/MainMenu.tscn",
                "preparation": "res://scenes/PreparationScene.tscn",
                "dungeon_map": "res://scenes/DungeonMap.tscn",
                "combat": "res://scenes/CombatScene.tscn",
                "rest": "res://scenes/RestScene.tscn",
                "game_over": "res://scenes/GameOverScreen.tscn"
            }
            var scene = scene_map.get(phase, "res://scenes/MainMenu.tscn")
            _change_game_phase_and_scene(phase, scene)
            print("GameManager: Loaded game state from %s" % save_path)
        else:
            printerr("GameManager: Invalid data in %s" % save_path)
    else:
        printerr("GameManager: Failed to open %s for loading" % save_path)


# --- Getter Functions for other managers to access game state ---
func get_current_party_data() -> Array:
    return current_party_members

func get_player_inventory() -> Dictionary:
    return player_inventory

func get_current_dungeon_state() -> Dictionary:
    return current_dungeon_state

func get_current_game_phase() -> String:
    return current_game_phase

## Helper to check if at least one party member is alive
func _party_is_alive() -> bool:
    for member in current_party_members:
        if member.get("hp", 0) > 0:
            return true
    return false

## Ends the current run and optionally starts another
##  save_slot: if provided, game state will be saved to this slot
##  show_results: display a summary/run results scene before returning to menu
##  repeat: immediately start a new run with surviving party members
func end_current_run(save_slot: String = "", show_results: bool = false, repeat: bool = false, results_scene: String = "res://scenes/MainMenu.tscn") -> void:
    print("GameManager: Ending current run.")
    if save_slot != "":
        save_game_state(save_slot)

    var survivors := current_party_members.duplicate(true)

    if repeat and _party_is_alive():
        print("GameManager: Restarting run with surviving party.")
        start_new_run(survivors)
        return

    reset_game_state()

    if show_results:
        # A dedicated summary scene could be shown here. Use the provided scene path or main menu as placeholder.
        _change_game_phase_and_scene("run_summary", results_scene)
    else:
        _change_game_phase_and_scene("main_menu", "res://scenes/MainMenu.tscn")


# --- Scene/Phase Transition Logic ---
## Helper function to change game phase and current scene.
func _change_game_phase_and_scene(new_phase: String, scene_path: String) -> void:
    print("GameManager: Changing phase to '%s', scene to '%s'." % [new_phase, scene_path])
    current_game_phase = new_phase

    # Scene changing logic
    var result = get_tree().change_scene_to_file(scene_path)
    if result != OK:
        printerr("GameManager: Error changing scene to %s. Result code: %s" % [scene_path, result])
        # Potentially handle error, e.g., by trying to go to a fallback scene or main menu.
        return

    emit_signal("game_phase_changed", new_phase) # For UI or other global listeners

async func change_to_rest():
    get_tree().change_scene_to_file("res://scenes/RestScene.tscn")
    await get_tree().process_frame
    var rest_mgr = get_tree().current_scene.get_node("RestManager")
    rest_mgr.rest_complete.connect(on_rest_continue)


# --- Handler Functions for Signals from Other Managers ---
## Called when PreparationManager signals party is ready for the dungeon.
func on_party_ready_for_dungeon() -> void: # Removed arguments as PrepManager now uses getters
    print("GameManager: Party ready for dungeon. Transitioning to DungeonMap.")
    # current_party_members should have been updated by PreparationManager via direct setters or by saving to a shared resource.
    # For this pattern, assume PreparationManager calls getters on GameManager if it needs fresh data,
    # or GameManager fetches from PrepManager if data is modified there.
    # Simpler: Assume PrepManager has updated any necessary global state or its own state that DungeonMapManager will use.

    _change_game_phase_and_scene("dungeon_map", "res://scenes/DungeonMap.tscn") # Example path
    call_deferred("_notify_dungeon_map_manager_to_initialize")

func _notify_dungeon_map_manager_to_initialize():
    # Node path constants for managers were removed; this function remains as a placeholder
    # in case direct communication with DungeonMapManager is reintroduced.
    pass

func on_node_selected(node_type: String) -> void:
    on_map_node_selected(node_type)

func on_map_node_selected(node_type: String) -> void:
    match node_type:
        "combat":
            _change_game_phase_and_scene("combat", "res://scenes/CombatScene.tscn")
        "rest":
            _change_game_phase_and_scene("rest", "res://scenes/RestScene.tscn")
        "loot":
            _change_game_phase_and_scene("loot", "res://scenes/LootPanel.tscn")
        _:
            print("GameManager: Unknown node type '%s' selected." % node_type)


## Called when DungeonMapManager requests a transition to combat.
func on_transition_to_combat_requested(combat_setup_data: Dictionary) -> void:
    # combat_setup_data should include { "enemies": [EnemyResource/Data], "environment_effects": [] (optional) }
    print("GameManager: Transition to combat requested.")
    _change_game_phase_and_scene("combat", "res://scenes/CombatScene.tscn") # Example path

    call_deferred("_notify_combat_manager_to_initialize", combat_setup_data)

func _notify_combat_manager_to_initialize(combat_setup_data: Dictionary):
    # Node path constants for managers were removed; this function remains as a placeholder
    # in case direct communication with CombatManager is reintroduced.
    pass


## Called when DungeonMapManager requests a transition to a loot or event node.
func on_transition_to_loot_event_requested(event_data: Dictionary) -> void:
    # This is a placeholder. How loot/events are handled (popups vs. scenes) affects this.
    # If they are full scenes:
    #   _change_game_phase_and_scene("event", "res://path_to_event_scene.tscn")
    #   Then, get the EventManager node and initialize it with event_data.
    # If they are popups managed within DungeonMapManager, DungeonMapManager handles it,
    # and GameManager might only need to know if game state changes significantly (e.g., item obtained).
    # For now, assume DungeonMapManager handles these as popups or internal UI changes.
    # If a scene change IS required, DungeonMapManager should emit a more specific signal
    # that GameManager is connected to, similar to on_transition_to_combat_requested.
    print("GameManager: Loot/event interaction requested (data: %s). Assuming DungeonMapManager handles UI." % str(event_data))
    # No phase/scene change here unless events are dedicated scenes.


## Called when DungeonMapManager requests a transition to a rest area.
func on_transition_to_rest_requested(_rest_setup_data: Dictionary = {}) -> void: # Added default for calls from PostBattle
    print("GameManager: Transition to rest requested.")
    _change_game_phase_and_scene("rest", "res://scenes/RestScene.tscn") # Example path

    call_deferred("_notify_rest_manager_to_initialize")

func _notify_rest_manager_to_initialize():
    # Node path constants for managers were removed; this function remains as a placeholder
    # in case direct communication with RestManager is reintroduced.
    pass


## Called when CombatManager signals victory.
func on_combat_victory(results: Dictionary) -> void:
    print("GameManager: Combat victory reported.")
    # results typically: { "loot": [], "xp_gained": 0, "final_party_state": [CombatantState] }

    # The final_party_state from combat (HP, statuses) needs to be passed to PostBattleManager.
    # PostBattleManager will then merge this with survival stats (fatigue, etc.)

    # No scene change yet, PostBattleManager handles the intermediate logic.
    current_game_phase = "post_battle_victory" # Internal sub-phase
    emit_signal("game_phase_changed", current_game_phase)

    # Placeholder for post-battle processing; actual manager interaction removed due to undefined path constants
    change_to_loot()

func change_to_combat():
    print("GameManager.change_to_combat()")
    get_tree().change_scene_to_file("res://scenes/CombatScene.tscn")

func on_combat_ended(victory):
    if victory:
        change_to_post_battle()
    else:
        get_tree().change_scene_to_file("res://scenes/GameOver.tscn")

func on_post_battle_continue():
    change_to_rest()

func change_to_post_battle() -> void:
    get_tree().change_scene_to_file("res://scenes/PostBattleSummary.tscn")
    await get_tree().process_frame
    var post_mgr = get_tree().current_scene.get_node("PostBattleManager")
    post_mgr.post_battle_complete.connect(on_post_battle_continue)

func on_rest_continue() -> void:
    _change_game_phase_and_scene("dungeon_map", "res://scenes/DungeonMap.tscn")
    call_deferred("_notify_dungeon_map_manager_to_initialize")

# Remove old scene transition logic if fully replaced.
# The old on_combat_finished, on_loot_complete, on_rest_complete are now handled by the new signal system.

async func change_to_loot() -> void:
    get_tree().change_scene_to_file("res://scenes/LootPanel.tscn")
    await get_tree().process_frame